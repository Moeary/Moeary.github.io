---
title: AI浪潮下的小容量硬盘自救办法(媒体文件方面)
date: 2025-11-20 10:54:00 +0800
categories: [ffmpeg, Tech]
tags: [tech] # TAG names should always be lowercase
mermaid: true
---

## 前言
当前时间是2025年11月。如果你现在去电脑城（如果还存在的话）或者电商平台逛一圈，你会发现AI浪潮不仅席卷了科技新闻，还顺手洗劫了我们的钱包。机械硬盘、内存、显卡……这些曾经唾手可得的电子榨菜，现在价格高得让人想报警。

在这个“万物皆涨，唯有工资不涨”的悲惨局势下，购买新硬件简直是给资本家送钱。既然开源（买硬盘）无望，那只能节流（压缩文件）了。看着那根红得发紫的C盘进度条，是不是感到一阵窒息？别慌，今天我们就来聊聊如何用技术手段，把那些臃肿的媒体文件“脱水”，帮你那可怜的硬盘挤出一点生存空间。

## 压缩技术详解

知己知彼，百战不殆。在开始动刀之前，我们先得了解一下我们要处理的对象。

### 图片

*   **JPG/JPEG**: 图片界的老前辈。虽然兼容性无敌，但它是有损压缩，压狠了就会出现“电子包浆”效果（满屏马赛克）。
*   **PNG**: 无损压缩，支持透明背景。画质是好了，但体积也跟着上去了，简直是硬盘杀手。
*   **WebP**: Google推出的“全能选手”。兼顾了JPG的体积和PNG的透明/无损特性。在同等画质下，体积通常只有JPG/PNG的一半甚至更少。这是我们今天的重点推荐。
*   **AVIF**: 新晋网红，压缩率比WebP还变态。但考虑到兼容性问题（虽然2025年应该好多了，但为了稳妥起见），我们还是先抱紧WebP的大腿。
*   **JPEG XL**: 传说中的JPEG继任者。支持无损转码（可以把现有的JPG无损转成JXL，体积减小20%），解码速度快，支持HDR。虽然浏览器支持度一度坎坷，但在2025年的今天，它已经逐渐站稳了脚跟。
*   **WebP 2**: Google的下一代图片格式，虽然还在实验阶段，但潜力巨大。

这里有一张对比图，大家可以感受一下不同格式在无损压缩下的表现（JPEG XL和WebP 2简直是降维打击）：


![无损压缩比较](https://raw.githubusercontent.com/Moeary/pic_bed/main/img/202511201157795.png)
*(注：图片来源于[月球背面](https://moonvy.com/blog/post/2022/next-generation-Image-format-2022/),具体对比在里面可以详细查看,实际效果取决于具体图片内容)*

### 音频

*   **WAV**: 原始录音格式，未压缩。音质虽好，但体积大得离谱。除非你是要拿去混音的专业人士，否则留着它就是浪费空间。
*   **MP3**: 有损压缩的代名词。虽然经典，但在同码率下，音质不如后来的AAC和Opus。
*   **FLAC**: 无损压缩，音频界的WinRAR。它能把WAV的体积压缩到一半左右，而音质丝毫不损。这是我们存档音乐的首选。

### 视频

视频是硬盘占用的“大户”。

*   **H.264 (AVC)**: 兼容性之王，上到4090下到诺基亚都能播。但它的压缩效率在今天看来已经有点“不够看”了。
*   **H.265 (HEVC)**: 压缩效率比H.264高约50%，但专利费贵得离谱，而且对播放设备有一定要求。
*   **AV1**: 今天的重头戏！开源、免费、无专利费。压缩效率比H.265还要高30%左右。唯一的缺点是……编码的时候，你的CPU可能会发出尖叫（非常吃算力）。

#### 画质评估：VMAF与FFMetrics

在压缩视频时，我们最怕的就是“压过头”了，把4K压成像素风。怎么判断画质损失了多少呢？靠眼睛看太累，这时候就需要科学的指标。

**VMAF (Video Multimethod Assessment Fusion)**
这是Netflix开发的一个画质评估算法，它模拟了人类视觉系统，给视频打分（0-100）。简单来说：
*   **95+**: 肉眼几乎看不出区别。
*   **80-90**: 仔细看能看出一点瑕疵，但完全可以接受。
*   **<70**: 甚至不如去买个眼镜。

**FFMetrics**
如果你觉得命令行看VMAF分数太枯燥，想要可视化的图表，那么 [**FFMetrics**](https://github.com/fifonik/FFMetrics) 是你的好帮手。它是一个基于FFmpeg的GUI工具，可以直观地展示PSNR, SSIM, VMAF等指标的曲线图。你可以清晰地看到视频的每一帧画质如何，哪里压崩了，哪里还能再压。对于强迫症患者来说，看着那条绿色的VMAF曲线维持在95以上，简直比股票涨了还开心。

## FFmpeg介绍：多媒体界的“神”

FFmpeg，全称 **Fast Forward MPEG**，它是多媒体处理界的“瑞士军刀”，或者更准确地说，它是这个领域的“神”。你所见到的几乎所有视频播放器（VLC, PotPlayer）、转码软件（格式工厂, 剪映导出功能）、在线视频网站的后台处理，背后流淌的血液都是 FFmpeg。

它是一个开源的命令行工具，虽然看着黑乎乎的窗口有点硬核，但一旦上手，你会发现那些花里胡哨的 GUI 软件在它面前都弱爆了。它支持几乎所有的音视频格式，能转码、能剪辑、能加滤镜，甚至能煮咖啡（开玩笑的，但它能让你的 CPU 热到能煮咖啡）。

### 开源协议与“耻辱柱”

FFmpeg 采用 **LGPL** 或 **GPL** 许可证（取决于你启用了哪些组件）。简单来说，这两个协议要求：如果你使用了 FFmpeg 的源代码，你也必须开源你的软件（GPL），或者至少允许用户替换其中的 FFmpeg 库（LGPL）。

然而，很多商业软件为了省事，直接把 FFmpeg 塞进自己的产品里，却不遵守开源协议。FFmpeg 官方曾维护过一个“耻辱柱”，公开点名那些违反协议的软件。

### 那些“套皮”软件们

市面上 99% 的视频转换工具，本质上都是给 FFmpeg 穿了一层衣服（GUI Shell）。

*   **小丸工具箱**: 一代经典。它就是一个非常纯粹的 FFmpeg 图形化界面，界面简洁，功能实用，深受压制组喜爱。可惜早已停止更新，但依然能在 Win10/11 上发光发热。
*   **ShanaEncoder**: 韩国开发的优秀转码软件。它本质上就是一个**壳子**。虽然它功能强大，但它的核心依然是 FFmpeg。对于追求极致的用户，你需要自己去 FFmpeg 官网下载最新的二进制文件并配置好路径，这样才能让这个“壳子”发挥出最新的性能。
*   **格式工厂**: 大家都用过，但名声不太好。它大量使用了 FFmpeg 的代码，却长期违反开源协议（不开源、不声明），属于典型的“吃完饭砸锅”。虽然功能大而全，但因为这种行为，在开源社区里一直备受鄙视。

所以，与其用那些广告满天飞的盗版“套皮”软件，不如直接拥抱 FFmpeg敲打命令行，或者使用像 ShanaEncoder 这样尊重开源精神的优秀 GUI。

## 压缩技术应用

好了，理论讲完了，开始实操。请打开你的终端（CMD/PowerShell/Bash），准备接受命令行的洗礼。

### 图片

我们要把臃肿的PNG和JPG转换成WebP。

**PNG转无损WebP** (保留所有细节，体积减半)：
```bash
ffmpeg -i input.png -c:v libwebp -lossless 1 output.webp
```

**JPG转有损WebP** (肉眼看不出区别，体积暴减)：
```bash
ffmpeg -i input.jpg -c:v libwebp -quality 80 output.webp
```
*   `-quality 80`: 质量系数，范围0-100。通常75-80是最佳平衡点。

### 音频

把巨大的WAV转换成小巧的FLAC。

**WAV转FLAC**：
```bash
ffmpeg -i input.wav -c:a flac output.flac
```
简单粗暴，效果拔群。

### 视频

这是重头戏。我们要把H.264/H.265的视频转换成AV1。

#### 硬件压缩 (速度快，质量一般)

如果你有一张不错的显卡（比如NVIDIA RTX 40/50系，或者Intel Arc），可以使用硬件编码器。速度飞快，但同码率下画质不如软件编码。

**注意：硬件编码器对AV1的支持有严格的要求**

并不是所有显卡都支持AV1硬件编码/解码。在激进地投入AV1怀抱之前，你需要检查一下自己的硬件是否"有这个能力"：

*   **NVIDIA**: 只有RTX 40系及以上的显卡才支持AV1硬件编码。RTX 30系只支持AV1硬件**解码**，不能编码。更老的显卡？那就只能用H.264/H.265了，别想了。
*   **Intel**: Arc系列GPU支持AV1编码。而集成显卡方面，12代酷睿（Alder Lake）及以上可以硬解AV1，但编码支持有限。
*   **AMD**: RDNA 2及以上的GPU支持AV1硬解，但编码支持还在路上。

**如何查询你的硬件是否支持AV1？**

别靠记忆，直接上这几个官方工具查询：
*   [NVIDIA编解码查询](https://bluesky-soft.com/en/dxvac/deviceInfo/decoder/nvidia.html)
*   [Intel编解码查询](https://bluesky-soft.com/en/dxvac/deviceInfo/decoder/intel.html)
*   [AMD编解码查询](https://bluesky-soft.com/en/dxvac/deviceInfo/decoder/amd.html)

找到你的GPU型号，就能清晰地看到它支持什么编解码器。

**手机端的情况更惨**

如果你想在手机上播放AV1视频，要求也不低：
*   高通：从骁龙8 Gen 2才开始支持AV1硬解
*   苹果：iPhone 16系列才支持
*   更老的手机？把那个AV1视频转回H.264吧，别折腾了

**所以，硬件编码的现实：**

如果你的显卡是GTX 1080、2080、RTX 30系等"老将"，你只能用软件编码（CPU方案）。别指望硬件加速了，那是RTX 40系及以后的特权。

**NVIDIA显卡 (NVENC，需要RTX 40系+)**:
```bash
ffmpeg -i input.mp4 -c:v av1_nvenc -cq 30 -c:a libopus -b:a 128k output.mkv
```

**Intel显卡 (QSV，Arc系列)**:
```bash
ffmpeg -i input.mp4 -c:v av1_qsv -global_quality 30 -c:a libopus -b:a 128k output.mkv
```

**AMD显卡 (暂不推荐AV1编码，生态还不成熟)**:
等等吧，或者用软件编码。

#### 软件(CPU)压缩 (速度慢，质量极好)

如果你追求极致的压缩率和画质，并且不介意电脑通宵工作，那么**SVT-AV1**是你的神。

```bash
ffmpeg -i input.mp4 -c:v libsvtav1 -crf 30 -preset 6 -c:a libopus -b:a 128k output.mkv
```

*   `-crf 30`: 恒定质量因子。数值越大，画质越差，体积越小。AV1通常推荐25-35。
*   `-preset 6`: 预设速度。范围0-13。数字越小越慢，压缩率越高。通常4-6是甜点区间。如果你想烤机，可以试试0。
*   `-c:a libopus`: 音频编码改用Opus，它是目前低码率下音质最好的音频编码器，比AAC强多了。

### 其他软件压缩视频

如果你觉得命令行太反人类，这里有两个“懒人神器”。

#### [ab-av1](https://github.com/alexheretic/ab-av1)

这是一个基于FFmpeg的命令行工具，但它会自动帮你寻找最佳的CRF参数。你只需要告诉它“我要VMAF 95分”，它就会自动跑测试，找到能达到这个画质的最小体积参数。
优点是压缩率特别高,我见到的最高的是能把近100GB的视频文件压缩成2GB,比正常用SVT-AV1压缩率都要高

![逆天压缩比](https://raw.githubusercontent.com/Moeary/pic_bed/main/img/202511201206938.png)

```bash
ab-av1 auto-encode -i input.mp4 --min-vmaf 95
```
简直是强迫症福音。

#### ShanaEncoder

如果你连命令行都不想看，那就用ShanaEncoder。这是一款韩国开发的转码软件，界面友好，功能强大。它内置了FFmpeg，你只需要点点鼠标，选选参数（记得选AV1编码），然后点击“开始”，就可以去睡觉了。

教程详细见[ShanaEncoder 最详细的视频压缩教程](https://www.bilibili.com/opus/897137927311589378)

### 懒人进阶：自动化脚本

虽然命令行很帅，但一张张图、一个个视频去敲命令，手指头也会断的。这时候，我们需要**批处理脚本**。

我自己写了一个简单的Windows批处理脚本 (`.bat`)，只需把图片拖进去，就能自动调用FFmpeg把它们转成WebP。

```batch
@echo off
setlocal enabledelayedexpansion

:: ====================================================
:: 检查 FFmpeg 是否可用
:: ====================================================
where ffmpeg >nul 2>nul
if %errorlevel% neq 0 (
    echo 错误: 未找到 ffmpeg.exe。
    echo 请确保 ffmpeg.exe 位于 PATH 环境变量中，
    echo 或将其放置在此脚本所在的文件夹中。
    echo.
    pause
    exit /b 1
)

echo.
echo ====================================================
echo   JPG/PNG 智能转 WebP 转换器
echo ====================================================
echo.

:: ====================================================
:: 设置 JPG/JPEG 转换为有损 WebP 的质量 (0-100, 100为最高质量，文件最大)
:: 建议值: 70-90，您可以根据需求调整此值。
:: ====================================================
set "webp_lossy_quality=80"

:: ====================================================
:: 检查输入参数数量
:: ====================================================
if "%~1"=="" (
    echo 错误: 请拖放一个或多个 JPG/JPEG/PNG 文件，或一个包含图片的文件夹到此脚本上。
    echo.
    pause
    exit /b 1
)

:: ====================================================
:: 处理拖放的文件或文件夹
:: ====================================================
set "input_count=0"
set "converted_count=0"
set "failed_count=0"

:process_arg
if "%~1"=="" goto :end_processing

set "current_path=%~f1"

:: 检查是否是文件夹
if exist "%current_path%\" (
    echo 正在处理文件夹: "%current_path%"
    echo.
    :: 遍历文件夹及其子文件夹中的 JPG, JPEG 和 PNG 文件
    for /r "%current_path%" %%F in (*.jpg *.jpeg *.png) do (
        call :convert_image "%%F"
    )
) else (
    :: 检查是否是图片文件
    call :check_and_convert "%current_path%"
)

shift
goto :process_arg

:check_and_convert
set "check_file=%~1"
set "check_ext=%~x1"
if /i "%check_ext%"==".jpg" (
    call :convert_image "%check_file%"
) else if /i "%check_ext%"==".jpeg" (
    call :convert_image "%check_file%"
) else if /i "%check_ext%"==".png" (
    call :convert_image "%check_file%"
) else (
    echo 跳过不支持的文件格式: "%check_file%" - 仅支持 JPG/JPEG/PNG
    echo.
)
goto :eof

:convert_image
set "input_file=%~1"
set "output_dir=%~dp1"
set "output_name=%~n1.webp"
set "output_file=%output_dir%%output_name%"
set "current_ext=%~x1"

set /a input_count+=1

echo 正在转换: "%input_file%"

:: 根据文件扩展名选择不同的 FFmpeg 参数
if /i "%current_ext%"==".png" (
    echo   - 检测到 PNG 文件, 使用无损 WebP 模式
    :: FFmpeg 命令解释 (无损 WebP):
    :: -i "%input_file%" : 指定输入文件
    :: -lossless 1       : 启用 WebP 无损压缩模式
    :: -compression_level 6 : WebP编码的压缩级别 (0-6, 6为最高压缩率, 但编码时间最长)
    :: -y                : 覆盖同名输出文件而不询问
    :: "%output_file%"   : 指定输出文件路径和名称
    ffmpeg -i "%input_file%" -lossless 1 -compression_level 6 -y "%output_file%" >nul 2>&1
    goto :check_result
)
if /i "%current_ext%"==".jpg" (
    echo   - 检测到 JPG 文件, 使用有损 WebP 模式 (质量: %webp_lossy_quality%)
    :: FFmpeg 命令解释 (有损 WebP for JPG):
    :: -i "%input_file%" : 指定输入文件
    :: -q:v %webp_lossy_quality% : 指定 WebP 视频质量 (0-100)
    :: -y                : 覆盖同名输出文件而不询问
    :: "%output_file%"   : 指定输出文件路径和名称
    ffmpeg -i "%input_file%" -q:v %webp_lossy_quality% -y "%output_file%" >nul 2>&1
    goto :check_result
)
if /i "%current_ext%"==".jpeg" (
    echo   - 检测到 JPEG 文件, 使用有损 WebP 模式 (质量: %webp_lossy_quality%)
    ffmpeg -i "%input_file%" -q:v %webp_lossy_quality% -y "%output_file%" >nul 2>&1
    goto :check_result
)
echo 错误: 内部处理错误, 文件类型未匹配: %input_file%
set /a failed_count+=1
goto :eof

:check_result
    echo 转换成功: "%output_file%"
    set /a converted_count+=1
) else (
    echo 转换失败: "%input_file%" - 请检查FFmpeg输出或源文件是否损坏
    set /a failed_count+=1
)
echo.
goto :eof

:end_processing
echo.
echo ====================================================
echo   所有文件处理完成。
echo ====================================================
echo   总共检测到 %input_count% 个 JPG/JPEG/PNG 文件。
echo   成功转换: %converted_count% 个文件。
if %failed_count% gtr 0 (
    echo   转换失败: %failed_count% 个文件。
)
echo.
echo 操作完成。
pause
endlocal
```

**授人以鱼不如授人以渔**：

在2025年，你不需要自己精通Shell或Batch语法。你只需要打开你的AI助手（比如Copilot），对它说：“帮我写一个Windows批处理脚本，遍历当前文件夹下的所有mp4文件，用ffmpeg转换成av1格式，保留原文件名但后缀改为mkv。”

几秒钟后，你就能得到一个完美的脚本。复制，粘贴，保存为 `.bat` (Windows) 或 `.sh` (Linux/Mac)，运行，然后去喝咖啡吧。让AI为我们打工，这才是2025年该有的生活方式。

## 结语

硬盘有价，数据无价（虽然大部分是下载了从来没看过的日本电影😈）。

通过这些方法，希望你的硬盘能再坚持个两三年，等到AI泡沫破裂，或者……等到我们买得起新硬盘的那一天。在那之前，请善待你的每一个字节，毕竟在2025年，它们比等质量的黄金还贵。

节省硬盘空间，人人有责！😤😤
