---
title: 编译原理复习
date: 2024-05-21 8:04:00 +0800
categories: [Tech,Compiler]
tags: [Tech]     # TAG names should always be lowercase
mermaid: true
---
## 未完 待施工
## 前言

转眼间,这个semester也来到了学期末,在考试之神和DDL之神的双重压迫下能做的也只有痛苦的接受.本着复习也要尽到舍己为人的义务,就此写下一份编译原理的复习指南,倘若后来者能够学习到上面,那也不枉我的一片赤忱之心.

本复习指南使用的是<<编译原理>> 陈意云著(实际就是龙书的低质量翻译版本还翻译不全,要想学的好,还建议去看原书)

鄙人学校考试只考10道简答题和两道综合大题,题目至于是什么,大概率会从自测题里面抽,简答题和自测题我会放在每一章的最后面以供参考
### 第一章 引论
**编译器,翻译器,解释器**




#### 自测题:
结合常用的语言，例如JAVA、Python 、C、C++等，说明：

1.什么是编译程序

* 编译程序是一种翻译器,不过一般是从高级语言翻译到低级语言的计算机程序,比如Gcc,Clang,llvm等

2.什么是解释程序

* 解释程序是用来直接执行源程序所制定的运算,比如Html,JavaScript

3.什么是翻译程序

* 能够完成从一种语言到另一种语言的保语义变换的软件称为翻译程序,比如百度翻译谷歌翻译都是翻译程序

4.以上3种程序的区别

* 编译程序:完成从高级语言到低级语言的转换,需要进行完整的编译过程

* 解释程序:效率比编译程序低,边执行边编译,无需完整的编译过程,但是词法分析,语法分析,语义分析只需要进行一次

* 翻译程序:只是用来保语义翻译

5.简述什么是编译前端和编译后端，编译前端包括编译器的哪几个阶段？

* 编译前端负责处理源代码的词法分析和语法分析,语义分析,生成中间代码,前端一般只依赖于源语言程序,独立于机器架构
* 编译后端负责中间代码优化、目标代码生成和目标代码优化，以提高程序的执行效率和性能,后端只依赖于机器架构,独立于高级语言
* 编译前端包括:词法分析,语法分析,语义分析

#### 综合题
#### 1.论述编译过程的每个阶段的输入及输出，以及每个阶段所采用的相关技术（P6图1.3）, 以声明语句和算术表达式语句的处理过程为例。
![](https://raw.githubusercontent.com/Moeary/pic_bed/main/img/202406091952696.png)
1. 词法分析（Lexical Analysis）：
输入： 源程序代码 "position=initial+rate*60"
输出： 词法单元（Token）序列 <id,1> <=> <id,2> <+> <id,3> <*> <60>
2. 语法分析（Syntax Analysis）：
输入： 词法单元序列 <id,1> <=> <id,2> <+> <id,3> <*> <60>
输出： 语法树（Syntax Tree）
3. 语义分析（Semantic Analysis）：
输入： 语法树
输出： 经过语义检查和类型检查的语法树，并可能进行类型转换
4. 中间代码生成（Intermediate Code Generation）：
输入： 经过语义分析的语法树
输出： 中间代码，例如三地址码（Three-Address Code） 
5. 代码优化（Code Optimization）：
输入： 中间代码
输出： 经过优化的中间代码
图中展示了将常量表达式 "id3 * 60.0" 直接计算出来，简化了后续计算。
6. 代码生成（Code Generation）：
输入： 经过优化的中间代码
输出： 目标代码，例如汇编代码或机器代码

### 第二章 词法分析

#### 自测题
1、	词法分析器常用的构造方法有哪几种？
* 手动构造,自动构造(使用类似Yacc的词法分析器进行构造)

2、判断如下图所示的有限自动机是NFA还是DFA，并判断它能识别何种字符串，给出它对应的状态转换表。
![](https://raw.githubusercontent.com/Moeary/pic_bed/main/img/202406091950774.png)
为NFA
能识别(a)*(a|b)字符串

| 状态\输入 | a     | b     |
| -------- | ----- | ----- |
| 1        | 1, 2 | 2     |
| 2        | END   | END   | 


### 第三章 语法分析

#### 自测题
1.什么是上下文无关文法，上下文无关文法由哪几部分组成（文法的定义）。
* 形式地说,一个上下文无关文法G是一个四元组(Vt,Vn,S,P), 用于描述上下文无关语言。它定义了一组规则，用于生成语言中的所有字符串。
* Vt是终结符,Vn是非终结符,S是开始符号,P是产生式有限集合

2.LL（1）文法和LR文法适用于哪些语句的语法分析？适用于哪些语句的语义分析？并给出原因（理由）。
* LL文法自顶向下语法分析器,适合简单语句,不适合语义分析,不具备回溯功能
* LR 文法自底向上语法分析器,适合一切语句,具备完整上下文信息和语法制导翻译, 更适合一切的语义分析

3.预测分析器模型由哪些部分组成。
* 栈,输入,预测分析程序,分析表M,输出
 ![](https://raw.githubusercontent.com/Moeary/pic_bed/main/img/202406091949500.png)

4.LR分析器模型由哪些部分组成。
* 输入,栈,LR分析驱动程序,分析表,输出
 ![](https://raw.githubusercontent.com/Moeary/pic_bed/main/img/202406091949757.png)

5.自上而下语法分析的基本思想。

* 自上而下语法分析，也称为预测型语法分析，其基本思想是从文法的起始符号开始，尝试推导出与输入符号串完全匹配的符号序列。它采用了一种类似于“预测”的方式，根据当前已有的符号和文法规则，尝试预测下一个应该出现的符号，并逐步构建语法树。

6．自下而上语法分析的基本思想

* 自下而上语法分析，也称为移进-归约分析，是一种从输入符号串开始，逐步将其归约为文法起始符号的语法分析方法。它不像自上而下分析那样进行预测，而是根据已扫描的符号和文法规则，尝试将输入符号串的子串“归约”成相应的非终结符，最终目标是将整个输入符号串归约成文法的起始符号。

#### 综合题

#### 一．完成分析以下文法 G 的 LL(1) 预测分析器（语法分析器）的构造。

**(1) L → E;L | ε**       
**(2) E → TE'**  
**(3) E' → +TE' | -TE' | ε**
**(4) T → FT'**  
**(5) T' → *FT' | /FT' | mod FT' | ε**
**(6) F → (E) | id | num** 

#### 1. 给出或画出预测分析器模型的组成

预测分析器模型由以下部分组成：

* **栈:** 用于存储文法符号，初始状态下栈底为 `$`，栈顶为文法开始符号 `S`。
* **分析表:**  一个二维表格，根据栈顶符号和当前输入符号决定语法分析器的动作（移进、归约、接受、报错）。
* **输入语句:**  待分析的符号串，末尾添加结束符 `#`。
* **分析程序:**  根据分析表和当前输入符号对栈进行操作，控制语法分析过程。

**模型示意图:**

```
     ┌────────┐     ┌────────┐
输入语句 --> │ 分析程序 │ --> 分析结果
     └────────┘     └────────┘
        ▲   │
        │   │
        │   ▼
     ┌────────┐
     │   栈   │
     └────────┘
        ▲
        │
        │
     ┌────────┐
     │ 分析表 │
     └────────┘
```

#### 2. 构造预测分析表

|     | id  | num | (  | )  | +  | -  | *  | /  | mod | ;  | #  |
|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|-----|
| **L** | L→E;L | L→E;L | L→E;L |     |     |     |     |     |     | L→E;L | L→ε |
| **E** | E→TE' | E→TE' | E→TE' |     |     |     |     |     |     |     |     |
| **E'** |     |     |     | E'→ε | E'→+TE' | E'→-TE' |     |     |     | E'→ε | E'→ε |
| **T** | T→FT' | T→FT' | T→FT' |     |     |     |     |     |     |     |     |
| **T'** |     |     |     | T'→ε | T'→ε | T'→ε | T'→*FT' | T'→/FT' | T'→mod FT' | T'→ε | T'→ε |
| **F** | F→id | F→num | F→(E) |     |     |     |     |     |     |     |     |

#### 3. 给出驱动器算法的伪代码

```python
# 初始化
ip = 0  # 输入指针，指向 ω# 中的第一个终结符
stack = ['$']  # 初始化栈，栈底符号为 $
stack.append('S')  # 将文法开始符号 S 压入栈中
top = stack[-1]  # 栈顶指针，指向栈顶元素

# 循环直到分析结束
while True:
  # 获取栈顶符号和当前输入符号
  A = top
  a = input_string[ip]

  # 查表
  if (A, a) in parsing_table:
    action = parsing_table[(A, a)]

    # 根据动作类型执行相应操作
    if action.startswith("移进"):
      # 将当前输入符号压入栈中
      stack.append(a)
      # ip 指向下一个输入符号
      ip += 1
    elif action.startswith("归约"):
      # 获取产生式右侧符号个数
      production_right = action.split("→")[1]
      beta_len = len(production_right)
      # 从栈中弹出 |β| 个符号
      for i in range(beta_len):
        stack.pop()
      # 将 A 压入栈中
      stack.append(action.split("→")[0])
      # 输出归约信息（可选）
      print(f"归约 {action}")
    elif action == "接受":
      # 分析成功
      print("分析成功")
      break
  else:
    # 分析表中没有对应的条目，报错
    print("语法错误")
    break

  # 更新栈顶指针
  top = stack[-1]
```

#### 4. 填表给出用此分析器分析句子 id * id + id; # 的过程

| 步骤 | 栈    | 输入    | 动作           |
|------|-------|---------|----------------|
| 1    | $L    | id*id+id;# | L→E;L         |
| 2    | $E;L  | id*id+id;# | E→TE'         |
| 3    | $T;LE' | id*id+id;# | T→FT'         |
| 4    | $FT';LE' | id*id+id;# | F→id          |
| 5    | $idT';LE' | *id+id;# | 移进           |
| 6    | $id*T';LE' | id+id;# | T'→*FT'       |
| 7    | $id*FT'T';LE' | id+id;# | F→id          |
| 8    | $id*idT'T';LE' | +id;# | 移进           |
| 9    | $id*id+T'T';LE' | id;# | T'→ε          |
| 10   | $id*id+T';LE' | id;# | T'→ε          |
| 11   | $id*id+;LE' | id;# | E'→+TE'       |
| 12   | $id*id+TE';LE' | id;# | T→FT'         |
| 13   | $id*id+FT'E';LE' | id;# | F→id          |
| 14   | $id*id+idT'E';LE' | ;# | 移进           |
| 15   | $id*id+id;E';LE' | # | T'→ε          |
| 16   | $id*id+id;E';L | # | E'→ε          |
| 17   | $id*id+id;L | # | L→ε          |
| 18   | $id*id+id; | # | 移进           |
| 19   | $id*id+id;# |  | 接受           |

### 5. 填表给出用此分析器分析句子 id + id * ; # 的过程

分析过程略，该句子无法被该文法识别，分析过程中会出现语法错误。


#### 二．有文法 G： 

**(1) E → E + T**      
**(2) E → T**        
**(3) T → T * F**      
**(4) T → F**        
**(5) F → (E)**      
**(6) F → i**        

#### 1. 完成表 2 中 LR 分析器利用 LR 分析表和驱动器对输入串 i * i + i 进行分析的过程
#### 2.若在语法分析同时进行语义分析，请在有语义翻译动作的步骤中标出，无语义翻译动作的步骤中空白，如步骤1~步骤3。
| 步骤 | 栈内容     | 当前输入 | 移进-规约动作             | 语义动作                               |
|------|------------|----------|--------------------------|----------------------------------------|
| 1    | #0         | i*i+i#   | 移进：s5                  |                                        |
| 2    | #0i5       | *i+i#   | 规约：r6 (F→i)         | F.val := i.val                       |
| 3    | #0F3       | *i+i#   | 规约：r4 (T→F)         | T.val := F.val                       |
| 4    | #0T2       | *i+i#   | 移进：s7                  |                                        |
| 5    | #0T2*7     | i+i#   | 移进：s5                  |                                        |
| 6    | #0T2*7i5   | +i#     | 规约：r6 (F→i)         | F.val := i.val                       |
| 7    | #0T2*7F5   | +i#     | 规约：r4 (T→F)         | T.val := F.val                       |
| 8    | #0T2*7T10  | +i#     | 规约：r3 (T→T*F)       | T.val := T.val * F.val              | 
| 9    | #0T2       | +i#     | 规约：r2 (E→T)         | E.val := T.val                       |
| 10   | #0E1       | +i#     | 移进：s6                  |                                        |
| 11   | #0E1+6     | i#      | 移进：s5                  |                                        |
| 12   | #0E1+6i5   | #      | 规约：r6 (F→i)         | F.val := i.val                       |
| 13   | #0E1+6F3   | #      | 规约：r4 (T→F)         | T.val := F.val                       |
| 14   | #0E1+6T9   | #      | 规约：r1 (E→E+T)       | E.val := E.val + T.val              |
| 15   | #0E1       | #      | 接受：acc                |                                        | 
### 第四章 语义分析

#### 自测题
1、	简述语法制导翻译的基本思想

* 利用上下文无关文法描述程序的语法结构。为文法的每个产生式规则关联一组语义动作（Semantic Actions）。 这些动作定义了如何根据产生式规则中的语法成分来计算语义属性或生成中间代码。

* 在语法分析过程中，当识别出一个产生式规则时，就执行与该规则相关联的语义动作。

2、	文法符号的属性有哪两类，两类属性的计算过程是怎样的？
![](https://raw.githubusercontent.com/Moeary/pic_bed/main/img/202406091942354.png)
* 综合属性和继承属性  
* 综合属性的值只能通过其子节点的属性值来计算。信息从语法树的底部向上流动。
* 继承属性的值可以通过其父节点、兄弟节点或自身节点的属性值来计算。信息可以在语法树中横向或向下流动。

### 第六章 运行时存储空间的组织和管理

#### 自测题
1 JAVA、Python 、C、C++语言的编译系统应该采用哪种存储分配策略，并简述理由。

2 编译系统常见的存储分配策略有几种？它们都适合于什么性质的语言？
### 第七章 中间代码生成

#### 自测题
一．给出下面表达式的语法树和有向无环图DAG(重复计算的式子连起来就行)。
（1）P201图7.2
![](https://raw.githubusercontent.com/Moeary/pic_bed/main/img/202406091940501.png)
（2）c=a*(b-c)- (b-c-5)
 
（3）c=(a+b)*(c+d)-(a+b+c)
 

### 第八章 代码生成

#### 自测题

1、	简述编译过程中代码优化必须遵循的原则
* 等价原则 经过优化后不应改变程序运行的结果
* 有效原则 使优化后的目标代码运行时间较短,占用的存储空间较小
* 合算原则 应尽可能以较低的代价取得较好的优化效果

2、对中间代码中基本块的优化和循环优化都是与机器无关的代码优化吗？请给出3-5种对中间代码优化的方法。
* 删除局部公共子表达式
* 删除死代码
* 交换相邻的独立语句
